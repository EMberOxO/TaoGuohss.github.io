{"pages":[],"posts":[{"title":"Math.random()取随机整数","text":"Math.random():获取0~1随机数 Math.floor() method rounds a number DOWNWARDS to the nearest integer, and returns the result. (小于等于 x，且与 x 最接近的整数。)其实返回值就是该数的整数位：Math.floor(0.666) –&gt; 0Math.floor(39.2783) –&gt; 39 所以我们可以使用Math.floor(Math.random())**去获取你想要的一个范围内的整数。如：现在要从1~52内取一个随机数：首先Math.random()*52** //这样我们就能得到一个 &gt;=0 且 &lt;52的数然后加1：**Math.random()*52 + 1** //现在这个数就 &gt;=1 且 &lt;53再使用Math.floor取整 最终: *Math.floor(Math.random()52 + 1) 这就能得到一个取值范围为1~52的随机整数了. -————————————————————————————————————– 12345678910111213141516171819Math.(random/round/cell/floor)随机数的用法Math.random() 返回值是一个大于等于0，且小于1的随机数Math.random()*N 返回值是一个大于等于0，且小于N的随机数 Math.round() 四舍五入的取整Math.ceil() 向上取整，如Math.cell(0.3)=1 、又如Math.ceil(Math.random()*10) 返回1~10Math.floor() 向下取整，如Math.floor(0.3)=0、又如Math.floor(Math.random()*10)返回0~9 引申：Math.round(Math.random()*15)+5; 返回5~20随机数Math.round(Math.random()*(y-x))+x; 返回x~y的随机数，包换负数。 转载至使用Math.floor和Math.random取随机整数_hsany330的专栏-CSDN博客","link":"/2021/07/16/Math.random()%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0/"},{"title":"Hello World","text":"初始博客,由hexo搭建我的第一个博客 2021/2/10","link":"/2021/02/09/hello-world/"},{"title":"确定类型","text":"确定类型typeof操作符最适合作为用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回”object“，如下列例子所示: 123456789101112let s = 'Ember';let b = true;let i = 22;let u;let n = null;let o = new Object();console.log(typeof s); //stringconsole.log(typeof b); //booleanconsole.log(typeof i); //numberconsole.log(typeof u); //undefinedconsole.log(typeof n); //objectconsole.log(typeof o); //object typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而想知道它是什么类型的对象。为了解决这个问题，ECMscript提供了instanceof操作符，语法如下: 1result = variable instanceof constructor 如果变量是给定引用类型的实例，则instanceof操作符返回true。来看下面的例子: 123console.log(person instanceof Object);//变量person是Object吗?console.log(colors instanceof Array);//变量colors是Array吗?console.log(pattern instanceof RegExp);//变量pattern是RegExp吗? 按照定义，所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。","link":"/2021/05/22/%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}]}